import Box from '@mui/material/Box';
import { TreeItem } from '@mui/x-tree-view/TreeItem';
import TextField from '@mui/material/TextField';

import { ASTNode } from '@solidity-parser/parser/src/ast-types'
import { useState } from 'react';
import { state } from './ContractState'


/*
I'm thinking of a design like this:

- `Novation A`
--- `Section` (Contract / Interface / Library / ..)
----- `Clause` (Function / Struct / Enum / Event / ..)
--- `Delegation` to B (delegatecall to address B)
----- `Section` / `Clause` ..
- `Novation B`
-- `Clause` (floating functions, etc.)
--- `Section`
------ `Clause` (internal funcs, etc.)
*/

type AstDefinitionProps = {
  id: string
  node: ASTNode
  onclick?: (e) => void
  children?: React.ReactNode
}

const NodeTypeMap = {
  'ContractDefinition': (node) => {
    return 'ðŸ“œ ' + node.kind + ' ' + node.name
  },
  'FunctionDefinition': (node) => {
    if (node.isConstructor)
      return null

    let [weiValue, setWeiValue] = useState(0n)
    let [retValue, setRetValue] = useState('<ret val here>')
    // console.log(node)

    return (
      <div className="flex flex-col mx-10 gap-2 text-black-500 p-1">
        {node.parameters.length > 0 && node.parameters.map((param) => {
          let type = param.typeName.name || param.typeName.namePath
          return (
            <TextField variant="outlined" label={type + ' ' + (param.name || "")} size="small" onChange={(e)=>{setRetValue('demo: ' + e.target.value)}} />
          )
        })}
        {
          node.stateMutability == 'payable' && (
            <TextField variant="outlined" label="value (wei)" size="small" onChange={(e)=>{setWeiValue(BigInt(e.target.value))}} />
        )}
        {node.returnParameters && node.returnParameters.length > 0 && node.returnParameters.map((param) => {
          let type = param.typeName.name || param.typeName.namePath
          return (
            <>
              <hr />
              <TextField variant="outlined" label={type + ' ' + (param.name || "")} value={retValue} size="small" />
            </>
          )
        })}
      </div>
    )
  },
  'EventDefinition': (node) => {},
  'StructDefinition': (node) => {},
  'EnumDefinition': (node) => {},
  'StateVariableDeclaration': (node) => {
    let type = node.variables[0].typeName
    if (type.type == 'ElementaryTypeName')
      return (null)

    let keyType
    if (type.keyType) {
      keyType = type.keyType.name ||  type.keyType.namePath
    }

    return (
      <TextField variant="outlined" label={keyType} size="small" />
    )
  }
}

const ContractTreeNode = ({
      id,
      node,
      onclick,
      children,
      ...props
    }: AstDefinitionProps
  ) => {
  // let { className, emoji } = KindMap[kind] || { emoji: '', className: '' }
  // let map = { ...EmptyMap, ...(NodeTypeMap[node.type] || {}) }

  return (
    <TreeItem nodeId={id} key={id} label={map.label(node)} onClick={onclick} className={map.className} {...props}>
      {map.widget ? map.widget(node, children) : children}
    </TreeItem>
  )
}

export default ContractTreeNode


// const ContractTreeNodeDeployment = ({
//       id,
//       node,
//       onclick,
//       children,
//       ...props
//     }: AstDefinitionProps
//   ) => {
//   // let { className, emoji } = KindMap[kind] || { emoji: '', className: '' }
//   let map = { ...EmptyMap, ...(NodeTypeMap[node.type] || {}) }

//   return (
//     <TreeItem nodeId={id} key={id} label={map.label(node)} onClick={onclick} className={map.className} {...props}>
//       {map.widget ? map.widget(node, children) : children}
//     </TreeItem>
//   )
// }

// export default ContractTreeNodeDeployment
