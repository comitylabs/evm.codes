---
fork: Prague
group: Stack Memory Storage and Flow Operations
---

*Index 1 is top of the stack. See [PUSH](/#60).*

## Notes

The program counter (PC) is a byte offset in the deployed [code](/about). It indicates which instruction will be executed next. When an [ADD](/#01) is executed, for example, the PC is incremented by 1, since the instruction is 1 byte. The [PUSH](/#60) instructions are bigger than one byte, and so will increment the counter accordingly.

The **RJUMPI** instruction may alter the program counter with relative offset, thus breaking the linear path of the execution to another point in the deployed [code](/about). It is used to implement functionalities like loops and conditions.

It offer reduced gas cost compare to dynamic counterpart.

## Stack input

0. `relative_offset`: byte relative offset in the deployed [code](/about) where execution will continue from.

## Stack output

0. `condition`: the program counter will be altered with the new value only if this value is different from 0. Otherwise, the program counter is simply incremented and the next instruction will be executed.

## Example

*TBD: example in playground*

## Error cases

The state changes done by the current context are [reverted](#FD) in those cases:
- Not enough gas.
- Not enough values on the stack.
- The code is legacy bytecode.
- Declare at the end of code section.
- Target outside of code bounds, or an immediate operand.
